group LLVM;

import "inputAndOutput.stg"

// the base of every program
base(code, declarations) ::= <<
; system
declare i32 @printf(ptr, ...)
declare i32 @putchar(i32)
declare ptr @malloc(i32)
declare void @free(ptr)

; library
declare i32 @print_int(i32)
declare i32 @print_true()
declare i32 @print_false()
declare i32 @print_newline()
declare i32 @print_string(ptr)

<declarations>

define i32 @main() {
start:
<code>

ret i32 0
}
>>

block(code) ::= <<
<code>
>>

// New variable/table declaration and maybe assigment
DeclarationAndAssignment(compute_value, value_register, has_value, memory_register, type) ::= <<
; variable initialization
<compute_value>
<memory_register> = alloca <type>
<if(has_value)>
store <type> <value_register>, ptr <memory_register>
<endif>
>>

//store [2 x [3 x i32]] [ [3 x i32] [i32 0, i32 1, i32 2], [3 x i32] [i32 3, i32 4, i32 5] ], ptr %vyplaty_32

// Assign to an existing variable
VariableAssignment(compute_value, value_register, memory_register, type) ::= <<
<compute_value>
store <type> <value_register>, ptr <memory_register>
>>

GetTableElement(memory_register, type, base_type, label_id, index_registers, calculate_index, return_register) ::= <<
<calculate_index>
%element_pos_<label_id> = getelementptr <type>, ptr <memory_register>, <index_registers>
<return_register> = load <base_type>, ptr %element_pos_<label_id>
>>

SetTableElement(memory_register, type, base_type, label_id, index_registers, calculate_index, calculate_value, value_register) ::= <<
<calculate_value>
<calculate_index>
%element_pos_<label_id> = getelementptr <type>, ptr <memory_register>, <index_registers>
store <base_type> <value_register>, ptr %element_pos_<label_id>
>>

GetFromVariable(return_register, memory_register, type) ::= <<
<return_register> = load <type>, ptr <memory_register>
>>


// Declare an array TODO
ArrayDeclaration(memory_register, label_id) ::= <<
%array_info_size_<label_id> = add
<memory_register> = call ptr @malloc(i32 4)
>>

// For loop
For(iter_memory_register, iter_value_register, cycle_end_register, aux_register, lower, upper, cycle_body, label_id) ::= <<
<iter_memory_register> = alloca i32
store i32 <lower>, i32* <iter_memory_register>
br label %cycle<label_id>

cycle<label_id>:
<iter_value_register> = load i32, i32* <iter_memory_register>
<cycle_end_register> = icmp sgt i32 <iter_value_register>, <upper>
br i1 <cycle_end_register>, label %endcycle<label_id>, label %iter<label_id>

iter<label_id>:
<cycle_body>
<aux_register> = add i32 <iter_value_register>, 1
store i32 <aux_register>, i32* <iter_memory_register>
br label %cycle<label_id>

endcycle<label_id>:
store i32 0, i32* <iter_memory_register>
>>

// If statement
// <cmp_register> = icmp <relation> i32 <value1_register>, <value2_register>
IfThenElse(compute_boolean, boolean_register, if_true, if_false, label_id) ::= <<
<compute_boolean>
br i1 <boolean_register>, label %iftrue<label_id>, label %iffalse<label_id>

iftrue<label_id>:
<if_true>
br label %fi<label_id>

iffalse<label_id>:
<if_false>
br label %fi<label_id>

fi<label_id>:
>>

IfThen(compute_boolean, boolean_register, if_true, label_id) ::= <<
<compute_boolean>
br i1 <boolean_register>, label %iftrue<label_id>, label %fi<label_id>

iftrue<label_id>:
<if_true>
br label %fi<label_id>

fi<label_id>:
>>

// binary operations between types
BinOp(compute_left, left_register, compute_right, right_register, return_register, instruction, type) ::= <<
<compute_left>
<compute_right>
<return_register> = <instruction> <type> <left_register>, <right_register>
>>

// comparison of numbers of types
RelationBinOp(compute_left, left_register, compute_right, right_register, return_register, instruction, type) ::= <<
<compute_left>
<compute_right>
<return_register> = icmp <instruction> <type> <left_register>, <right_register>
>>

// negative expression
Negative(compute_value, value_register, return_register) ::= <<
<compute_value>
<return_register> = sub i32 0, <value_register>
>>

// negation expression - we do it using 1 xor x
Negation(compute_value, value_register, return_register) ::= <<
<compute_value>
<return_register> = xor i1 1, <value_register>
>>

// plain integer
Number(const_value, return_register) ::= <<
<return_register> = add i32 <const_value>, 0
>>

// variable
Identifier(memory_register, return_register) ::= <<
<return_register> = load i32, i32* <memory_register>
>>

FunctionDefinition(name, return_type, arguments, code) ::= <<
define <return_type> @<name>(<arguments>) {
<code>
}
>>

FunctionCall(name, return_type, arguments, calculate_arguments, destination, is_not_void) ::= <<
<calculate_arguments>
<if (is_not_void)><destination> = <endif>call <return_type> @<name>(<arguments>)
>>

Return(type, value_register, compute_value) ::= <<
<compute_value>
ret <type> <value_register>
>>

ReturnNothing() ::= <<
ret void
>>
