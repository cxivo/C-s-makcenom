group LLVM;

import "inputAndOutput.stg"
import "lists.stg"

// the base of every program
base(code, declarations) ::= <<
; system
declare i32 @printf(ptr, ...)
declare i32 @putchar(i32)
declare ptr @malloc(i32)
declare ptr @calloc(i32, i32)
declare void @free(ptr)

; library
declare i32 @print_int(i32)
declare i32 @print_true()
declare i32 @print_false()
declare i32 @print_newline()
declare i32 @print_string(ptr)

; i32 size, i32 capacity, i32 reference count, ptr array itself
%ListType = type {i32, i32, i32, ptr}

define void @decrement_and_garbage_collect(ptr %list, i32 %layer) {
    ; decrement old list's reference counter
    %count_ptr = getelementptr %ListType, ptr %list, i32 0, i32 2
    %count = load i32, ptr %count_ptr
    %count_dec = sub i32 %count, 1
    store i32 %count_dec, ptr %count_ptr

    %is_zero = icmp eq i32 %count_dec, 0

    br i1 %is_zero, label %remove, label %still_used

; garbage collection itself
remove:
    %array_ptr = getelementptr %ListType, ptr %list, i32 0, i32 3
    %array = load ptr, ptr %array_ptr
    %size_ptr = getelementptr %ListType, ptr %list, i32 0, i32 0
    %size = load i32, ptr %size_ptr
    %layer_dec = sub i32 %layer, 1

    %is_last_layer = icmp eq i32 %layer, 0
    br i1 %is_last_layer, label %at_the_end, label %cycle

; if has sublists
cycle:
    %i = phi i32 [0, %remove], [%i_inc, %iterate]
    %done = icmp sge i32 %i, %size
    br i1 %done, label %at_the_end, label %iterate
iterate:
    %child_ptr = getelementptr ptr, ptr %array, i32 %i
    %child = load ptr, ptr %child_ptr

    call void @decrement_and_garbage_collect(ptr %child, i32 %layer_dec)

    %i_inc = add i32 %i, 1
    br label %cycle

; remove the list itself
at_the_end:
    call void @free(ptr %array)
    call void @free(ptr %list)
    ret void

still_used:
    ret void
}

<declarations>

define i32 @main() {
start:
<code>
    ret i32 0
}
>>

block(code) ::= <<
<code>
>>

// New variable/table declaration
Declaration(memory_register, type, code_after) ::= <<
; variable initialization
<memory_register> = alloca <type>
<code_after>
>>

// Assign to an existing variable
VariableAssignment(compute_value, value_register, memory_register, type, code_after) ::= <<
<compute_value>
store <type> <value_register>, ptr <memory_register>
<code_after>
>>

GetTableElement(memory_register, type, base_type, label_id, index_registers, calculate_index, return_register) ::= <<
<calculate_index>
%element_pos_<label_id> = getelementptr <type>, ptr <memory_register>, i32 0, <index_registers>
<return_register> = load <base_type>, ptr %element_pos_<label_id>
>>

SetTableElement(memory_register, type, base_type, label_id, index_registers, calculate_index, calculate_value, value_register) ::= <<
<calculate_value>
<calculate_index>
%element_pos_<label_id> = getelementptr <type>, ptr <memory_register>, i32 0, <index_registers>
store <base_type> <value_register>, ptr %element_pos_<label_id>
>>

LocateArrayElement(memory_register, type, index_registers, calculate_index, return_register) ::= <<
<calculate_index>
<return_register> = getelementptr <type>, ptr <memory_register>, <index_registers>
>>

GetFromVariable(return_register, memory_register, type) ::= <<
<return_register> = load <type>, ptr <memory_register>
>>

// For loop
For(iter_memory_register, iter_value_register, cycle_end_register, aux_register, lower, upper, cycle_body, label_id) ::= <<
<iter_memory_register> = alloca i32
store i32 <lower>, i32* <iter_memory_register>
br label %cycle<label_id>

cycle<label_id>:
<iter_value_register> = load i32, i32* <iter_memory_register>
<cycle_end_register> = icmp sgt i32 <iter_value_register>, <upper>
br i1 <cycle_end_register>, label %endcycle<label_id>, label %iter<label_id>

iter<label_id>:
<cycle_body>
<aux_register> = add i32 <iter_value_register>, 1
store i32 <aux_register>, i32* <iter_memory_register>
br label %cycle<label_id>

endcycle<label_id>:
store i32 0, i32* <iter_memory_register>
>>

// If statement
// <cmp_register> = icmp <relation> i32 <value1_register>, <value2_register>
IfThenElse(compute_boolean, boolean_register, if_true, if_false, label_id) ::= <<
<compute_boolean>
br i1 <boolean_register>, label %iftrue<label_id>, label %iffalse<label_id>

iftrue<label_id>:
<if_true>
br label %fi<label_id>

iffalse<label_id>:
<if_false>
br label %fi<label_id>

fi<label_id>:
>>

IfThen(compute_boolean, boolean_register, if_true, label_id) ::= <<
<compute_boolean>
br i1 <boolean_register>, label %iftrue<label_id>, label %fi<label_id>

iftrue<label_id>:
<if_true>
br label %fi<label_id>

fi<label_id>:
>>

// binary operations between types
BinOp(compute_left, left_register, compute_right, right_register, return_register, instruction, type) ::= <<
<compute_left>
<compute_right>
<return_register> = <instruction> <type> <left_register>, <right_register>
>>

// comparison of numbers of types
RelationBinOp(compute_left, left_register, compute_right, right_register, return_register, instruction, type) ::= <<
<compute_left>
<compute_right>
<return_register> = icmp <instruction> <type> <left_register>, <right_register>
>>

// negative expression
Negative(compute_value, value_register, return_register) ::= <<
<compute_value>
<return_register> = sub i32 0, <value_register>
>>

// negation expression - we do it using 1 xor x
Negation(compute_value, value_register, return_register) ::= <<
<compute_value>
<return_register> = xor i1 1, <value_register>
>>

// plain integer
Number(const_value, return_register) ::= <<
<return_register> = add i32 <const_value>, 0
>>

CharToInt(compute_value, value_register, return_register) ::= <<
<compute_value>
<return_register> = sext i8 <value_register> to i32
>>

IntToChar(compute_value, value_register, return_register) ::= <<
<compute_value>
<return_register> = trunc i32 <value_register> to i8
>>

// variable
Identifier(memory_register, return_register) ::= <<
<return_register> = load i32, i32* <memory_register>
>>

FunctionDefinition(name, return_type, arguments, code) ::= <<
define <return_type> @<name>(<arguments>) {
<code>
}
>>

FunctionCall(name, return_type, arguments, calculate_arguments, destination, is_not_void) ::= <<
<calculate_arguments>
<if (is_not_void)><destination> = <endif>call <return_type> @<name>(<arguments>)
>>

Return(type, value_register, compute_value) ::= <<
<compute_value>
ret <type> <value_register>
>>

ReturnNothing() ::= <<
ret void
>>
